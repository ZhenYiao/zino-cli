{{#if is_actix}}
use actix_web::{
    dev::{forward_ready, Service, ServiceRequest, ServiceResponse, Transform},
    Error,
};
use std::{
future::{ready, Future, Ready},
pin::Pin,
};
use zino::{prelude::*, Request};
{{/if}}
{{#if is_axum}}
use crate::model::User;
use axum::{middleware::Next, response::Response};
use zino::{prelude::*, Request, Result};
use zino_model::user::JwtAuthService;
{{/if}}
{{#if is_ntex}}
use ntex::{
    service::{Middleware, Service, ServiceCtx},
    web::{Error, ErrorRenderer, WebRequest, WebResponse},
};
use zino::{prelude::*, Request};
{{/if}}


{{#if is_actix}}
#[derive(Default)]
pub struct UserSessionInitializer;

impl&lt;S, B&gt; Transform&lt;S, ServiceRequest&gt; for UserSessionInitializer
where
    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
{
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type InitError = ();
    type Transform = UserSessionMiddleware&lt;S&gt;;
    type Future = Ready&lt;Result&lt;Self::Transform, Self::InitError&gt;&gt;;
    fn new_transform(&self, service: S) -&gt; Self::Future {
        ready(Ok(UserSessionMiddleware { service }))
    }
}

pub struct UserSessionMiddleware&lt;S&gt; {
    service: S,
}

impl&lt;S, B&gt; Service&lt;ServiceRequest&gt; for UserSessionMiddleware&lt;S&gt;
where
    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
{
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;

    forward_ready!(service);

fn call(&self, req: ServiceRequest) -&gt; Self::Future {
    let mut req = Request::from(req);
    match req.parse_jwt_claims(JwtClaims::shared_key()) {
        Ok(claims) =&gt; {
            if let Ok(session) = UserSession::&lt;Uuid&gt;::try_from_jwt_claims(claims) {
                req.set_data(session);
            } else {
            return Box::pin(async move {
                let message = "401 Unauthorized: invalid JWT claims";
                let rejection = Rejection::with_message(message).context(&req).into();
                let result: zino::Result&lt;Self::Response&gt; = Err(rejection);
                result.map_err(|err| err.into())
                });
            }
        }
        Err(rejection) =&gt; {
            return Box::pin(async move {
                    let result: zino::Result&lt;Self::Response&gt; = Err(rejection.into());
                    result.map_err(|err| err.into())
                });
            }
        }
        let req = ServiceRequest::from(req);
        let fut = self.service.call(req);
        Box::pin(async move {
            let res = fut.await?;
            Ok(res)
        })
    }
}

{{/if}}

{{#if is_axum}}
#[derive(Default)]
pub struct UserSessionInitializer;

pub async fn _init_user_session(mut req: Request, next: Next) -&gt; Result&lt;Response&gt; {
    let claims = req
    .parse_jwt_claims(JwtClaims::shared_key())
    .map_err(|rejection| rejection.context(&req))?;
    match User::verify_jwt_claims(&claims).await {
        Ok(verified) =&gt; {
            if verified {
                let session = UserSession::&lt;i64&gt;::try_from_jwt_claims(claims).extract(&req)?;
                req.set_data(session);
            } else {
                reject!(req, unauthorized, "invalid JWT claims");
            }
        }
        Err(err) =&gt; reject!(req, unauthorized, err),
    }
    Ok(next.run(req.into()).await)
}

pub async fn _check_admin_role(req: Request, next: Next) -&gt; Result&lt;Response&gt; {
    if req.request_method() == "POST" {
        if let Some(session) = req.get_data::&lt;UserSession&lt;i64&gt;&gt;() {
            if !session.has_role("admin") {
                reject!(req, unauthorized, "a role of `admin` is required");
            }
        }
    }
    Ok(next.run(req.into()).await)
}
{{/if}}

{{#if is_ntex}}
#[derive(Default)]
pub struct UserSessionInitializer;

pub struct UserSessionMiddleware&lt;S&gt; {
    service: S,
}

impl&lt;S&gt; Middleware&lt;S&gt; for UserSessionInitializer {
    type Service = UserSessionMiddleware&lt;S&gt;;

    fn create(&self, service: S) -&gt; Self::Service {
        UserSessionMiddleware { service }
    }
}

impl&lt;S, Err&gt; Service&lt;WebRequest&lt;Err&gt;&gt; for UserSessionMiddleware&lt;S&gt;
where
    S: Service&lt;WebRequest&lt;Err&gt;, Response = WebResponse, Error = Error&gt;,
    Err: ErrorRenderer,
{
    type Response = WebResponse;
    type Error = Error;

    ntex::forward_ready!(service);

async fn call(
&self,
req: WebRequest&lt;Err&gt;,
ctx: ServiceCtx&lt;'_, Self&gt;,
) -&gt; Result&lt;Self::Response, Self::Error&gt; {
    let mut req = Request::from(req);
    match req.parse_jwt_claims(JwtClaims::shared_key()) {
        Ok(claims) =&gt; {
            if let Ok(session) = UserSession::&lt;Uuid&gt;::try_from_jwt_claims(claims) {
                req.set_data(session);
            } else {
                let message = "401 Unauthorized: invalid JWT claims";
                let rejection = Rejection::with_message(message).context(&req).into();
                let result: zino::Result&lt;Self::Response&gt; = Err(rejection);
                return result.map_err(|err| err.into());
            }
        }
        Err(rejection) =&gt; {
            let result: zino::Result&lt;Self::Response&gt; = Err(rejection.into());
                return result.map_err(|err| err.into());
        }
    }
    let req = WebRequest::try_from(req)?;
    let res = ctx.call(&self.service, req).await?;
    Ok(res)
    }
}

{{/if}}